<h1 id="conical">Conical</h1>
<p>Conical is a work-in-progress systems language that uses
set-theoretic principals to make most invariants unrepresentable. It is
also planned to use scope-based lifetime inference to manage
resources.</p>
<p>There are currently 3 operating principles that are being used in the
design process:</p>
<ol type="1">
<li><p>If a specific feature can be implemented using a more general
one, the general one should be used</p></li>
<li><p>Its better for something to have more granular control with
incremental defaults than have it be based on a assumed
use-case</p></li>
<li><p>The compiler is much better at enforcing assumptions than humans
are</p></li>
</ol>
<p>Examples of each principle, in-order, are:</p>
<ol type="1">
<li><p>Since async functions are essentially just generators + global
state, and generators are just compiler-led transformation of a function
into a state-machine, both of these should be implemented using macros
instead of being a builtin compiler feature.</p></li>
<li><p>There is no “unsafe” keyword in Conical that just turns off all
safety checks, rather safety should be implemented using the type system
so that only the safety mechanisms that are required are used instead of
having something like Rust’s “unsafe blocks” which just completely turn
off any safety checks at all (in Rust either code is “safe” or it can do
anything without checks).</p></li>
<li><p>If you have a number that is required to be in a non-standard
range (e.g. 5-370 or something), in most languages you would have to
rely on runtime checks and documentation, in Conical you can make
exactly define every number that is allowed and, except in things like
external functions or intrinsics, that assumption is guaranteed</p></li>
</ol>
<h1 id="documentation">Documentation</h1>
<p>Currently there is no official documentation for the language as it
is still very early in design and implementation. However, there is a
design ideas / general syntax overview <a
href="./docs/book/language.md">here</a></p>
