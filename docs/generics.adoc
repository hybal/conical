= Generics
:hardbreaks:

A generic in conical refers to a local identifier that can be used as an unknown type, so any type can be used. Many things can use generics, but all of them require a declaration that you are using one.
[source, conical]
----
struct Foo<T> { 
    bar: T;
    b: i32;
}

fn print<T>(T val) {...} 

fn add<T>(a, b) :: (T, T) -> T => a + b;

impl<T> Foo<T> { //the first generic is declaring a generic T and the second one is passing that generic to Foo
    fn init(bar: T, b: i32) -> Self {
        Foo {bar, b}
    }
}

fn example() {
    let foo: Foo<&str> = Foo::init("abc", 1); //the type system will automatically detect the correct type to pass.
    print(foo);
}
----

